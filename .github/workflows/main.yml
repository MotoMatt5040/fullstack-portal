name: Build and Deploy to Testing

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allows manual triggering

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: testing  # ğŸ”‘ This targets your testing environment
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy and Build on Server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.TESTING_SSH_HOST }}
          username: ${{ secrets.TESTING_SSH_USERNAME }}
          key: ${{ secrets.TESTING_SSH_PRIVATE_KEY }}
          script: |
            echo "ğŸš€ Starting deployment at $(date)"
            
            # Use home directory for deployment (no sudo needed)
            DEPLOY_PATH="$HOME/fullstack-portal"
            echo "ğŸ“ Deploy path: $DEPLOY_PATH"
            
            # Remove old directory if it exists
            if [ -d "$DEPLOY_PATH" ]; then
              echo "ğŸ—‘ï¸ Removing existing directory..."
              rm -rf $DEPLOY_PATH
            fi
            
            # Create fresh directory
            mkdir -p $DEPLOY_PATH
            cd $DEPLOY_PATH
            
            # Clone repository
            echo "ğŸ“¦ Cloning repository..."
            git clone https://github.com/${{ vars.REPO_OWNER }}/${{ vars.REPO_NAME }}.git .
            
            echo "ğŸ”§ Current directory: $(pwd)"
            echo "ğŸ“‹ Files in repository:"
            ls -la
            
            # Verify docker-compose.yml exists
            if [ ! -f "docker-compose.yml" ]; then
              echo "âŒ docker-compose.yml not found! Listing all files:"
              find . -name "*.yml" -o -name "*.yaml" 2>/dev/null || true
              exit 1
            else
              echo "âœ… docker-compose.yml found"
            fi
            
            # Create comprehensive environment file from secrets
            echo "ğŸ”§ Creating environment file from secrets..."
            cat > .env.testing << 'EOF'
            NODE_ENV=testing
            VITE_ENV=testing
            
            # Domain Configuration
            VITE_DOMAIN_NAME=${{ secrets.VITE_DOMAIN_NAME }}
            FRONTEND_URL=${{ secrets.FRONTEND_URL }}
            VITE_DEV_API_URL=${{ secrets.VITE_DEV_API_URL }}
            VITE_DOCKER_API_URL=${{ secrets.VITE_DOCKER_API_URL }}
            
            # JWT Secrets
            ACCESS_TOKEN_SECRET=${{ secrets.ACCESS_TOKEN_SECRET }}
            REFRESH_TOKEN_SECRET=${{ secrets.REFRESH_TOKEN_SECRET }}
            
            # MongoDB Database
            DATABASE_URI=${{ secrets.DATABASE_URI }}
            
            # GitHub Integration
            FULLSTACK_PORTAL_ISSUES_TOKEN=${{ secrets.FULLSTACK_PORTAL_ISSUES_TOKEN }}
            REPO_OWNER=${{ vars.REPO_OWNER }}
            REPO_NAME=${{ vars.REPO_NAME }}
            
            # Email Configuration
            SMTP_HOST=${{ secrets.SMTP_HOST }}
            SMTP_PORT=${{ secrets.SMTP_PORT }}
            SMTP_USER=${{ secrets.SMTP_USER }}
            SMTP_PASS=${{ secrets.SMTP_PASS }}
            FROM_NAME=${{ secrets.FROM_NAME }}
            FROM_EMAIL=${{ secrets.FROM_EMAIL }}
            
            # Promark Database
            PROMARK_DB_USER=${{ secrets.PROMARK_DB_USER }}
            PROMARK_DB_PASSWORD=${{ secrets.PROMARK_DB_PASSWORD }}
            PROMARK_DB_SERVER=${{ secrets.PROMARK_DB_SERVER }}
            PROMARK_DB_NAME=${{ secrets.PROMARK_DB_NAME }}
            
            # Voxco Database
            VOXCO_DB_USER=${{ secrets.VOXCO_DB_USER }}
            VOXCO_DB_PASSWORD=${{ secrets.VOXCO_DB_PASSWORD }}
            VOXCO_DB_SERVER=${{ secrets.VOXCO_DB_SERVER }}
            VOXCO_DB_NAME=${{ secrets.VOXCO_DB_NAME }}
            
            # User Credentials
            MATT_USERNAME=${{ secrets.MATT_USERNAME }}
            MATT_PASSWORD=${{ secrets.MATT_PASSWORD }}
            
            # Voxco API
            VOXCO_API_USERNAME=${{ secrets.VOXCO_API_USERNAME }}
            VOXCO_API_PASSWORD=${{ secrets.VOXCO_API_PASSWORD }}
            VOXCO_API_CONTEXT=${{ secrets.VOXCO_API_CONTEXT }}
            VOXCO_WEB_API_ACCESS_KEY=${{ secrets.VOXCO_WEB_API_ACCESS_KEY }}
            
            OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
            
            # Docker Registry (if needed)
            DOCKER_REGISTRY=${{ secrets.DOCKER_REGISTRY }}
            IMAGE_TAG=testing
            
            # Compose Environment
            COMPOSE_ENV=testing
            EOF
            
            # Copy to main .env file for Docker Compose
            cp .env.testing .env
            
            echo "ğŸ“‹ Environment file created (showing non-sensitive vars):"
            grep -E "^(NODE_ENV|VITE_ENV|VITE_DOMAIN_NAME|FRONTEND_URL|COMPOSE_ENV|IMAGE_TAG)" .env
            
            # Stop any existing containers
            echo "ğŸ›‘ Stopping existing containers..."
            if docker compose -f docker-compose.testing.yml ps 2>/dev/null | grep -q "Up"; then
              docker compose -f docker-compose.testing.yml down
            else
              echo "No running containers to stop"
            fi
            
            # Clean up old images
            echo "ğŸ§¹ Cleaning up old images..."
            docker image prune -f
            
            # Build and start containers using the testing environment
            echo "ğŸ—ï¸ Building and starting containers..."
            export COMPOSE_ENV=testing
            docker compose -f docker-compose.testing.yml --env-file .env.testing build --no-cache
            docker compose -f docker-compose.testing.yml --env-file .env.testing up -d
            
            # Wait a moment for containers to start
            echo "â³ Waiting for containers to start..."
            sleep 30
            
            # Show container status
            echo "ğŸ“Š Container status:"
            docker compose -f docker-compose.testing.yml ps
            
            # Show logs
            echo "ğŸ“‹ Container logs (last 20 lines):"
            docker compose -f docker-compose.testing.yml logs --tail=20
            
            # Test if services are responding
            echo "ğŸ” Testing services..."
            
            # Test the actual domain through Caddy
            for i in {1..5}; do
              if curl -f "https://${{ secrets.VITE_DOMAIN_NAME }}/api/health" 2>/dev/null; then
                echo "âœ… API is accessible through domain"
                break
              else
                echo "â³ Attempt $i: API not responding through domain yet, waiting..."
                sleep 10
              fi
            done
            
            # Test if the main site loads
            for i in {1..3}; do
              if curl -f "https://${{ secrets.VITE_DOMAIN_NAME }}" 2>/dev/null; then
                echo "âœ… Website is accessible"
                break
              else
                echo "â³ Attempt $i: Website not responding yet, waiting..."
                sleep 10
              fi
            done
            
            # Show final status
            echo "âœ… Deployment completed at $(date)"
            echo "ğŸŒ Access your app at: ${{ secrets.FRONTEND_URL }}"

      - name: Show Deployment Status
        if: always()  # Run even if previous step failed
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.TESTING_SSH_HOST }}
          username: ${{ secrets.TESTING_SSH_USERNAME }}
          key: ${{ secrets.TESTING_SSH_PRIVATE_KEY }}
          script: |
            echo "ğŸ“Š Final deployment status:"
            cd $HOME/fullstack-portal
            
            echo "ğŸ³ Running containers:"
            docker compose -f docker-compose.testing.yml ps
            
            echo "ğŸ’¾ Disk usage:"
            df -h
            
            echo "ğŸ” Recent logs:"
            docker compose -f docker-compose.testing.yml logs --tail=15 --timestamps
            
            echo "ğŸŒ Port status:"
            netstat -tulpn | grep -E ":(80|443|5000|5173)" || echo "No services on expected ports"
            
            echo "ğŸ” Service Health Checks:"
            curl -s "https://${{ secrets.VITE_DOMAIN_NAME }}/api/health" || echo "âŒ API health check failed"
            curl -s "https://${{ secrets.VITE_DOMAIN_NAME }}" | head -1 || echo "âŒ Website health check failed"